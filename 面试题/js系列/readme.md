# 1. js数组上常用的方法
- 增： push()、splice()、unshift()、concat()
- 删： pop()、shift()、splice()、slice(start, end)
- 改： splice()、flat()
- 查： indexOf()、lastIndexOf()、includes()、find((item) => {})、findIndex((item) => {})、findLastIndex((item) => {})
- 迭代： 

forEach()
return在forEach()里无法终止迭代，只能靠try catch包裹forEach()来终止迭代

、map()、filter()、reduce()、some()、every()、sort()

# 2. 聊一下flat方法（数组扁平化）
口头描述 flat.js
- 是什么
flat是Array原型上的函数，用于将高维数组处理成低维数组

- 原理：
1. 递归
2. reduce +递归
3.  while+解构
4. toString()

# 3. 字符串身上常见的方法


- 增：concat()
- 删：slice()、subString()
- 改：replace()、toUpperCase() / toLowerCase()、trim()、padStart()、padEnd()、repeat()
- 查：indexOf()、lastIndexOf()、includes()、startsWith(searchValue) / endsWith(searchValue)、charAt()

- splice() match()

# 4.谈一谈JavaScript的类型转换机制
https://juejin.cn/post/7519437813471215651
- 是什么
js引擎在执行各种运算符时对于数据的类型是有要求的，如果数据类型和预期的不符合，就会发生类型转换

- 特点
1. 显示类型转换
借助构造函数来将一种类型转换成希望的类型，这其中如果时原始值转原始值，官方给出了直接的转换结果

引用类型转原始类型
1. ToNumber()||ToString()
2. ToPrimitive()
    1. 判断是否为原始类型，是则返回
    2. 否则调用valueOf(),得到原始值则返回
    3. 否则调用toString(),得到原始值返回
    4. 否则报错
3. 不是目标类型，继续调用

2. 隐式类型转换
通常发生在四则运算、比较运算、判断语句

# 5. 介绍一下js中的拷贝
https://juejin.cn/post/7525747511605493775#heading-7
- 是什么
因为js中原始类型存在栈中，引用类型存在堆中，再把引用地址存在栈中
拷贝通常只发生在引用类型上。效果是让新数据拥有和原数据一样的值
- 实现方法
1. 浅拷贝：拷贝对象的属性，值如果是引用类型则共用同一个地址
过滤隐式属性：hasOwnProperty()

2. 深拷贝：如果是引用类型，则创建新的对象进行新的拷贝，实现层层拷贝
MessageChannel() -- 不能处理function symbol
- 原理

1. 递归

# 说说你对闭包的理解

- 是什么
作用域规则，内部作用域一定能访问外部
调用栈规则，函数执行完后一定会被销毁弹出栈
当函数A中声明的函数B被拿到函数外调用时，为了保证上面两条规则都能正常运行函数执行后不会完全销毁，而是把函数B需要的变量保存到一个集合中，这个集合就是闭包，这样函数B在函数A销毁后依然能正常运行
闭包是一个集合


- 特点
1. 用于封装模块，避免全局变量污染
2. 延长了变量的生命周期

- 缺点
内存泄漏 -- 调用栈的可用空间变小
- 场景
1. 柯里化
2. 单例模式

说说你对 js 中作用域的理解
是什么 在一个区域中，生效了一些变量和函数，这种区域就叫作用域

特点

全局作用域

函数作用域

块级作用域

词法作用域 -- 描述的是一个函数所处的作用域

作用域链 js 引擎在查找变量时，会现在当前作用域中查找，找不到就会去外层作用域查找，层层往上，直到全局作用域，这种查找的链状关系就叫作用域链
# 8. 说说你对 js 中原型的理解
是什么 在 js 中原型分为两种，一种是函数的原型（显示原型），一种是对象的原型（隐式原型），显示原型指的是函数身上自带的属性 prototype，隐式原型指的是对象上的 proto 属性

特点 对象的 proto 指向创建它的构造函数的 prototype，因为js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 proto 上查找。所以原型存在的意义就是让实例对象可以访问到公共的方法

原型链 js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 proto 上查找， 还找不到就会顺着 proto 往上查找，直到找到 null 为止，这种查找关系就叫原型链

# 9. 说说 js 中的继承
是什么 让子类可以访问到父类的属性和方法

实现方式

原型链继承 -- 多个实例共享一个原型对象，相互影响

构造函数继承 -- 无法继承到父类原型上的属性

组合继承 -- 父类构造函数会执行两次，浪费性能

原型式继承 -- 多个实例共享一个原型对象，相互影响

寄生式继承 -- 同上

寄生组合式继承 -- 最优解

类继承 -- 利用 extends 关键字实现继承

# 10. 说说你对 js 中 this 的理解
是什么 this 是 js 中的一个关键字，它可以简化上下文的参数传递，提高代码复用性，它的指向是由函数调用的方式决定的

规则：

函数独立调用 --- 默认绑定规则 --- this 指向 window
函数被对象调用 --- 隐式绑定规则 --- this 指向该对象
call, apply, bind --- 显示绑定规则 --- this 指向绑定的对象
函数被 new 调用 --- 构造函数绑定规则 --- this 指向新创建的对象
# 11. 说说 js 中的事件流
是什么 js 中的事件流指的是事件在 DOM 中的传播顺序

特点：

事件从 window 上往目标处传播 （捕获阶段）
事件在目标处触发 （目标阶段）
事件从目标处往 window 传播 （冒泡阶段）
使用场景： 借助事件冒泡机制，实现事件委托
# 12. js 中的类型判断有哪些方法
typeof 只能判断除了 null 之外的原始类型 和 function
instanceof 只能判断引用类型
Array.isArray()
Object.prototype.toString.call(xx) -- 让xx 执行对象上的toString 方法
对象上的toString --- 返回一个由 '[object' 和 内部属性 [[Class]] 的值和 ']' 组成的字符串
数组上的toString --- 返回一个由数组元素组成的字符串，每个元素之间用逗号隔开
其他类型上的toString --- 返回一个字符串字面量，如：'123'

# 13. 说说你对 js 事件循环的理解
是什么 因为js 默认是单线程运行的，所以在执行代码的过程中遇到耗时任务就会发生阻塞，为了解决这个问题，js 设计了一套循环执行同步和异步的机制，这个机制就是事件循环机制

特点：

同步任务：立即执行的任务

异步任务：被挂起

微任务：Promise.then, MutationObserver, process.nextTick(node.js)
宏任务：script, setTimeout, setInterval, I/O, UI 渲染, postMessage, MessageChannel
先执行同步代码
执行微任务
有需要的话就进行渲染
执行宏任务 (第二次事件循环的开始)
# 14. 说说 js 中的防抖节流
是什么 是一种优化手段，比如搜索框的输入，scroll，click 等可能会在段时间内出发多次，非常浪费资源，防抖节流就是为了优化这种情况

特点：

防抖：在规定的时间内，如果存在多次事件的触发，只执行最后一次
节流：在规定的时间内，只执行一次
实现：
防抖: 将定时器存在闭包中，使全局可以访问同一个定时器。传入需要出发的回调函数和规定的时长。每次触发事件时，清除定时器，重新设置定时器。这样可以做到没有再触发事件后，定时器到期执行回调函数。
节流： 将第一次的事件设置为0，每次触发事件时获得当前的时间并将其与上一次触发事件的时间进行对比。如果时间差大于规定的时间，则执行回调函数，并将当前时间设置为上一次触发事件的时间。
# 15. js 中的本地存储有哪些，区别是什么？
cookies (这个空间中存放的内容 js 无法设置和修改，后端靠响应代码来存入)
大小：4k
过期时间：可以设置过期时间，不设置默认关闭浏览器就过期
工作原理：浏览器会在每次请求时，将 cookies 中的内容添加到请求头中，后端可以通过请求头来获取 cookies 中的内容
跨域：可以设置跨域
localstorage
大小：5M
过期时间：不可以设置过期时间，默认永久存在
工作原理：需要 js 手动存取
跨域：不可以跨域
sessionstorage
大小：理论上无穷大
过期时间：页面关闭就过期
工作原理：需要 js 手动存取
跨域：不可以跨域
indexdb (纯客户端的本地数据库)
大小：理论上无穷大
过期时间：不可以设置过期时间，默认永久存在
工作原理：需要 js 手动存取，支持存二进制
跨域：不可以跨域
适用场景：
存储大量数据
需要离线访问